---
title: 인증과 전자서명
category:
  - Security
---

## 양방향 암호화

내가 보낸 데이터를 **중간에서는 모르게, 받은 사람은 알 수 있게** 하는 것이 목적

### 대칭키 vs 공개키(비대칭키) 암호화

| 방식        | 대칭키               | 공개키 (비대칭키)    |
| ----------- | -------------------- | -------------------- |
| 설명        | 암복호화에 같은 키 사용 | 암복호화에 다른 키 사용 |
| 대표 알고리즘 | DES, AES, SEED      | RSA, DSA             |
| 장점        | 빠름                 | 키 교환 안정성       |
| 단점        | 키 교환 취약성       | 느림                 |

### 공개키 암호화 활용

- 2개의 키 중 어느 것을 공개키로 사용해도 무관
- **공개키**: 상대방에게 공개, **비밀키**: 본인만 보관

2가지 활용 방식:
1. 내 `비밀키`로 복호화: 누구나 암호화된 메시지를 보내고, **나만** 열어볼 수 있음
2. 내 `비밀키`로 암호화: 누구나 복호화하여 볼 수 있는 메시지, **나만이** 만들 수 있음

## 단방향 암호화

복호화가 불가능한 해시를 생성하여 변조되지 않았음을 증명

### 활용 사례

- `패스워드 암호화`: 원본 복원 불필요
- `전자서명`: 위변조 검증

### 대표 알고리즘

MD5, SHA-128, SHA-256, SHA-384, SHA-512

> `base64`는 인코딩/디코딩이 가능하므로 해시와는 다름

## 디지털 서명

> 네트워크에서 송신자의 신원을 증명하는 방법
> 송신자가 자신의 `비밀키로 암호화`한 메시지를 수신자가 송신자의 `공개키로 해독`하는 과정

### 3가지 알고리즘

- **키 생성 알고리즘**: 공개키 암호화 (RSA 등)
- **서명 생성 알고리즘**: 단방향 해싱 + 비밀키
- **서명 검증 알고리즘**: 단방향 해싱 + 공개키

### 디지털 서명 vs 전자 서명

- `디지털 서명`: 송신자가 자신의 신원을 증명하는 **절차**
- `전자 서명`: 그 절차의 특정 단계에서 사용하는 **정보**

### 프로세스

**송신자:**
1. 원본 문서(평문) 해싱
2. 해시값을 비밀키로 암호화 → 전자 서명 생성
3. 암호화된 전자 서명을 원본 문서에 첨부하여 전송

**수신자:**
1. 수신 문서(평문) 해싱
2. 첨부된 전자 서명을 공개키로 복호화
3. 두 해시값이 같으면 위변조 없음

## JWT (JSON Web Token)

> 인증 정보를 토큰에 담아 서버 간 상태 공유 없이 인증하는 방식

### JWT가 필요한 이유

기존 쿠키/세션/토큰 방식은 인증 정보를 확인하기 위해 DB I/O 필요
→ 사용자 정보를 토큰 자체에 담고 서명으로 위변조 방지

### JWT 구조

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9  (Header)
.eyJzdWIiOiIxMjM0NTY3ODkwIn0          (Payload)
.SflKxwRJSMeKKF2QT4fwpMeJf36POk6...   (Signature)
```

HTTP 헤더 (RFC 6750 Bearer 타입):
```
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

### HS256 vs RS256

| 방식   | 알고리즘        | 특징                                           |
| ------ | --------------- | ---------------------------------------------- |
| HS256  | HMAC + SHA-256  | 대칭키 방식, 모든 서버가 동일한 비밀키 공유 필요 |
| RS256  | RSA + SHA-256   | 비대칭키 방식, 인증서버가 발급(비밀키), 서비스가 검증(공개키) |

→ RS256으로 인증서버 병목 문제 해결

## HMAC

> HMAC = Hash(Message, Key) + Message

- 공유키를 이용하여 메시지 해시값을 양쪽에서 생성
- 메시지 위변조 여부 판단에 활용
- **Replay Attack 방어**: 메시지에 `timestamp` 포함, 특정 시간 경과 후 무효화

## SSL/TLS/HTTPS

| 용어   | 설명                                                          |
| ------ | ------------------------------------------------------------- |
| SSL    | 대칭키 + 공개키의 장점을 결합한 보안 프로토콜                |
| TLS    | SSL의 개선된 버전                                             |
| HTTPS  | HTTP 통신에 SSL/TLS가 적용된 버전                             |
| MITM   | 중간 트래픽에서 가짜 인증서를 보낸 뒤 HTTPS 복호화           |
| RootCA | 신뢰할 수 있는 제3의 인증기관으로 MITM 무력화                |

### SSL 동작 방식

1. 공개키 방식으로 대칭키를 안전하게 최초 교환
2. 이후 통신은 속도가 빠른 대칭키 방식으로 암호화

## 관련 노트

- [OpenSSL](/notes/OpenSSL/) - SSL/TLS 인증서 생성 실습
- [알고리즘](/notes/Algorithm/) - RSA, AES, DES 암호화 알고리즘
- [NodeJS](/notes/NodeJS/) - JWT Token 사용 예제

## 참고

- [RAON CTF - WEB Essential 암호화](https://joongbu.raonctf.com/essential/study/web/cryptography)
- [전송 계층 보안 (TLS) - 위키백과](https://ko.wikipedia.org/wiki/전송_계층_보안)
- [SSL과 인증서 구조 이해하기 (CA 중심으로)](https://m.blog.naver.com/alice_k106/221468341565)
- [[JWT] JWT란 무엇인가?](https://etloveguitar.tistory.com/101)
- [RS256 대 HS256: 차이점은 무엇입니까?](https://stackoverflow.com/questions/39239051/rs256-vs-hs256-whats-the-difference)
